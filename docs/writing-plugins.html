<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Writing plugins | Navy</title>
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://momentumft.github.io/navy/styles.css" />
  </head>
  <body>
    <div id="sidebar">
      <div id="logo">Na<span>v</span>y</div>

      <ul class="side-nav">
        <li>
          <a href="https://momentumft.github.io/navy/">Home</a>
        </li>
      </ul>

      
      <h4>Usage</h4>

      <ul class="side-nav">
        <li>
          <a href="https://momentumft.github.io/navy/docs/getting-started/1-intro.html">Getting started</a>
        </li>
        <li>
          <a href="https://momentumft.github.io/navy/docs/getting-started/2-day-to-day-usage.html">Day-to-day usage</a>
        </li>
        <li>
          <a href="https://momentumft.github.io/navy/docs/getting-started/3-develop.html">Developing services</a>
        </li>
        <li>
          <a href="https://momentumft.github.io/navy/docs/getting-started/4-multiple-navies.html">Working with Multiple Navies</a>
        </li>
      </ul>

      <h4>Advanced</h4>

      <ul class="side-nav">
        <li>
          <a href="https://momentumft.github.io/navy/docs/api-introduction.html">Node API tutorial</a>
        </li>
        <li>
          <a href="https://momentumft.github.io/navy/docs/writing-plugins.html">Writing plugins</a>
        </li>
        <li>
          <a href="https://momentumft.github.io/navy/docs/http-proxy.html">HTTP proxy</a>
        </li>
      </ul>

      <h4>Reference</h4>

      <ul class="side-nav">
        <li>
          <a href="https://momentumft.github.io/navy/docs/navyfile-config.html">Navyfile.js config</a>
        </li>
        <li>
          <a href="https://momentumft.github.io/navy/docs/api/">API Documentation</a>
        </li>
      </ul>
      
    </div>

    <div id="page">
      <h1 id="writingpluginsfornavy">Writing plugins for Navy</h1>

<p>Navy allows you to customise the CLI and manipulate services at runtime by using plugins.</p>

<p>Some examples of why you might want to use plugins:</p>

<ul>
<li><p><strong>Install custom Docker Registry certificate to the users machine before <code>navy launch</code> runs.</strong>
This improves the developer experience within your team if you require a custom certificate.</p></li>

<li><p><strong>Replace Docker image in <code>docker-compose.yml</code> with a copy on a local cache at runtime.</strong>
You might want to mirror your Docker images locally to reduce the load on your network. By writing a plugin,
you can change which images are being pulled at runtime.</p></li>

<li><p>...</p></li>
</ul>

<h2 id="usingplugins">Using plugins</h2>

<p>Plugins are defined in your projects <code>Navyfile.js</code> which lives in your project root.
<a href="navyfile-config.html">See Navyfile.js configuration reference</a>.</p>

<h2 id="writingplugins">Writing plugins</h2>

<p>Plugins are just standard node modules which export a function which gets passed a <code>Navy</code>.
Create a new folder with a <code>package.json</code> and <code>index.js</code>.</p>

<p><code>index.js</code>:</p>

<pre><code class="js language-js">module.exports = function (navy) {
  // plugin code here
}
</code></pre>

<p>Your plugin can now register middleware, provide custom commands for the CLI, or hook into various lifecycle events.</p>

<h2 id="customcommands">Custom commands</h2>

<p>A plugin can provide custom commands which the user can run using <code>navy run [command]</code>. This can be useful for workflow related operations which might be specific to your team. This is not meant to be used for commands related to the build of your app, this is more for utilities.</p>

<p>You can register a custom command in your <code>index.js</code>:</p>

<pre><code class="js language-js">function migrateData(navy) {
  console.log('Called migrate data command with navy %s', navy.name)
}

module.exports = function (navy) {
  navy.registerCommand('migrate-data', migrateData.bind(null, navy))
}
</code></pre>

<p>Now to test it, make sure you have a Navy set up called <code>dev</code> with a <code>Navyfile.js</code> in the project root with the plugin added to the plugins array.</p>

<p>Then run:</p>

<pre><code class="sh language-sh">$ navy run migrate-data
Called migrate data command with navy dev
</code></pre>

<p>Success!</p>

<h2 id="middleware">Middleware</h2>

<p>Middleware is responsible for manipulating the compose config at runtime. You register middleware by passing in a function which will get called with the current compose config, as well as the state of the current Navy, and the function should return new compose configuration. You can think of it as a set of reducers:</p>

<pre><code class="js language-js">// Pseudocode for how middleware gets run
const middleware = [/* registered middleware from plugins */]
const currentComposeConfig = /* your docker compose config */

const newComposeConfig = middleware.reduce(
  (composeConfig, middleware) =&gt; middleware(composeConfig),
  currentComposeConfig,
)
</code></pre>

<p>A middleware function looks like this:</p>

<p><code>index.js</code>:</p>

<pre><code class="js language-js">const {middlewareHelpers} = require('navy')

function newImageForService(service) {
  // Replace myorg/myimage with somelocalregistry.local/myorg/myimage
  if (service.image &amp;&amp; service.image.indexOf('myorg/') !== -1) {
    return service.image.replace('myorg/', 'somelocalregistry.local/myorg/')
  }

  return service.image
}

function replaceImage(config) {
  return middlewareHelpers.rewriteServices(config, service =&gt; ({
    ...service,
    image: newImageForService(service),
  }))
}

module.exports = function (navy) {
  navy.registerMiddleware(replaceImage)
}
</code></pre>

<p>The <code>replaceImage</code> function takes in the current compose config, and returns a new config object. The <code>middlewareHelpers.rewriteServices</code> is a helper function provided by Navy which will return a new config object with new config for each service based on the return value of the map callback provided.</p>

<p>So <code>replaceImage</code> will return something like:</p>

<pre><code class="js language-js">{
  version: 2,
  services: {
    myapp: {
      image: 'somelocalregistry.local/myorg/myimage',
      ports: ['80'],
    },
  },
}
</code></pre>

<p>Middleware functions should not mutate the config passed in and should instead return a new instance of the config.</p>

<p>The code snippet above will cause any service with the image <code>myorg/[somename]</code> to pull down <code>somelocalregistry.local/myorg/[somename]</code> instead.</p>

<h2 id="lifecyclehooks">Lifecycle hooks</h2>

<p>You can easily hook into various lifecycle hooks in Navy to add functionality.</p>

<p>For example, in <code>index.js</code>:</p>

<pre><code class="js language-js">function handleBeforeLaunch() {
  console.log('Before launch!')
}

module.exports = function (navy) {
  navy.on('cli.before.launch', handleBeforeLaunch)
}
</code></pre>

<p>Plugin hooks can be asynchronous and return a promise.</p>
    </div>
  </body>
</html>
